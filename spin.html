<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>V√≤ng quay may m·∫Øn - Lucky Wheel</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      color: #eee;
      padding: 20px;
    }
    h1 {
      text-align: center;
      margin-bottom: 24px;
      font-size: 1.75rem;
      color: #e94560;
    }
    .container {
      display: flex;
      gap: 32px;
      max-width: 1100px;
      margin: 0 auto;
      flex-wrap: wrap;
      justify-content: center;
    }
    /* --- B√™n tr√°i: V√≤ng quay --- */
    .wheel-section {
      flex: 0 0 auto;
      position: relative;
      width: 380px;
      height: 380px;
    }
    #wheelCanvas {
      display: block;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      box-shadow: 0 0 0 8px #e94560, 0 0 30px rgba(233, 69, 96, 0.4);
      background: #0f0f1a;
    }
    .wheel-pointer {
      position: absolute;
      top: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 20px solid transparent;
      border-right: 20px solid transparent;
      border-top: 36px solid #e94560;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
      z-index: 10;
      pointer-events: none;
    }
    /* --- B√™n ph·∫£i: ƒêi·ªÅu khi·ªÉn --- */
    .controls-section {
      flex: 1;
      min-width: 280px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .controls-section label {
      display: block;
      margin-bottom: 6px;
      font-weight: 600;
      color: #a0a0a0;
    }
    #optionsInput {
      width: 100%;
      min-height: 180px;
      padding: 12px;
      border-radius: 8px;
      border: 2px solid #333;
      background: #0f0f1a;
      color: #eee;
      font-size: 14px;
      resize: vertical;
    }
    #optionsInput:focus {
      outline: none;
      border-color: #e94560;
    }
    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s, box-shadow 0.15s;
    }
    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    .btn-primary {
      background: linear-gradient(135deg, #e94560, #c73e54);
      color: white;
    }
    .btn-secondary {
      background: #2d2d44;
      color: #eee;
      border: 1px solid #444;
    }
    .btn-spin {
      background: linear-gradient(135deg, #0f3460, #16213e);
      color: #e94560;
      border: 2px solid #e94560;
      font-size: 18px;
      padding: 14px 28px;
    }
    #spinBtn:disabled {
      opacity: 0.7;
    }
    .result-box {
      margin-top: 8px;
      padding: 12px;
      border-radius: 8px;
      background: rgba(233, 69, 96, 0.15);
      border: 1px solid #e94560;
      min-height: 48px;
      font-size: 18px;
      font-weight: 600;
      text-align: center;
      color: #ff6b6b;
    }
    .result-box.empty {
      color: #666;
      font-weight: normal;
      font-size: 14px;
    }
    /* --- Modal C√†i ƒë·∫∑t --- */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      z-index: 100;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .modal-overlay.show {
      display: flex;
    }
    .modal {
      background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
      border-radius: 12px;
      max-width: 480px;
      width: 100%;
      max-height: 90vh;
      overflow: hidden;
      border: 1px solid #333;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
    .modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid #333;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .modal-header h2 {
      font-size: 1.25rem;
      color: #e94560;
    }
    .modal-close {
      background: none;
      border: none;
      color: #aaa;
      font-size: 24px;
      cursor: pointer;
      padding: 0 4px;
      line-height: 1;
    }
    .modal-close:hover {
      color: #fff;
    }
    .modal-body {
      padding: 20px;
      overflow-y: auto;
      max-height: calc(90vh - 140px);
    }
    .setting-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    .setting-row label {
      flex: 1;
      min-width: 120px;
      margin: 0;
    }
    .setting-row input[type="number"] {
      width: 80px;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #0f0f1a;
      color: #eee;
      font-size: 14px;
    }
    .forced-select-wrap {
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid #333;
    }
    .forced-select-wrap label {
      display: block;
      margin-bottom: 8px;
    }
    #forcedResultSelect {
      width: 100%;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #0f0f1a;
      color: #eee;
      font-size: 14px;
    }
    .modal-footer {
      padding: 16px 20px;
      border-top: 1px solid #333;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    .weight-sum {
      font-size: 12px;
      color: #888;
      margin-top: 8px;
    }
    .weight-sum.error {
      color: #e94560;
    }
    .spin-settings-icon-btn {
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 50;
      width: 40px;
      height: 40px;
      padding: 0;
      border: none;
      background: rgba(0,0,0,0.2);
      color: rgba(255,255,255,0.7);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: background 0.2s, color 0.2s;
    }
    .spin-settings-icon-btn:hover {
      background: rgba(233, 69, 96, 0.4);
      color: #fff;
    }
  </style>
</head>
<body>
  <button type="button" id="settingsBtn" class="spin-settings-icon-btn" title="C√†i ƒë·∫∑t x√°c su·∫•t" aria-label="C√†i ƒë·∫∑t x√°c su·∫•t">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.04.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
  </button>
  <h1>üé° V√≤ng quay may m·∫Øn</h1>
  <div class="container">
    <section class="wheel-section">
      <div class="wheel-pointer"></div>
      <canvas id="wheelCanvas" width="380" height="380"></canvas>
    </section>
    <section class="controls-section">
      <label for="optionsInput">Danh s√°ch l·ª±a ch·ªçn (m·ªói d√≤ng 1 option)</label>
      <textarea id="optionsInput" placeholder="Option 1&#10;Option 2&#10;Option 3"></textarea>
      <button type="button" class="btn btn-primary" id="updateBtn">C·∫≠p nh·∫≠t v√≤ng quay</button>
      <button type="button" class="btn btn-spin" id="spinBtn">Quay</button>
      <div id="resultBox" class="result-box empty">K·∫øt qu·∫£ s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y</div>
    </section>
  </div>

  <!-- Modal C√†i ƒë·∫∑t -->
  <div id="settingsModal" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        <h2>C√†i ƒë·∫∑t x√°c su·∫•t</h2>
        <button type="button" class="modal-close" id="modalClose">&times;</button>
      </div>
      <div class="modal-body">
        <div id="settingsOptionsList"></div>
        <div class="weight-sum" id="weightSum">T·ªïng: 0%</div>
        <div class="forced-select-wrap">
          <label>Ch·ªçn:</label>
          <select id="forcedResultSelect">
            <option value="">-- Kh√¥ng ch·ªçn --</option>
          </select>
          <p class="weight-sum">Ch·ªâ c√≥ hi·ªáu l·ª±c 1 l·∫ßn, sau khi quay s·∫Ω reset.</p>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" id="modalCancel">H·ªßy</button>
        <button type="button" class="btn btn-primary" id="modalSave">L∆∞u</button>
      </div>
    </div>
  </div>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <script>
    // ========== Firebase Config ==========
    const firebaseConfig = {
      apiKey: "AIzaSyAj8MNZXEN1tQaOqZ4jGxGhX04IWAW437s",
      authDomain: "xehtml.firebaseapp.com",
      databaseURL: "https://xehtml-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "xehtml",
      storageBucket: "xehtml.firebasestorage.app",
      messagingSenderId: "295057234622",
      appId: "1:295057234622:web:814425305c34e22cf81cef",
      measurementId: "G-CEQ6GP1D3Z"
    };

    // Kh·ªüi t·∫°o Firebase
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();
    const DB_PATH = 'luckyWheel';

    // ========== State ==========
    let options = []; // [{ name: string, weight: number }], weight l√† %
    let forcedResult = null; // index (number) ho·∫∑c null
    let currentRotation = 0; // g√≥c hi·ªán t·∫°i c·ªßa b√°nh xe (rad)
    let isSpinning = false;
    let canvas, ctx;

    // ========== DOM ==========
    const wheelCanvas = document.getElementById('wheelCanvas');
    const optionsInput = document.getElementById('optionsInput');
    const updateBtn = document.getElementById('updateBtn');
    const spinBtn = document.getElementById('spinBtn');
    const resultBox = document.getElementById('resultBox');
    const settingsModal = document.getElementById('settingsModal');
    const modalClose = document.getElementById('modalClose');
    const modalCancel = document.getElementById('modalCancel');
    const modalSave = document.getElementById('modalSave');
    const settingsOptionsList = document.getElementById('settingsOptionsList');
    const forcedResultSelect = document.getElementById('forcedResultSelect');
    const weightSumEl = document.getElementById('weightSum');

    // √Åp d·ª•ng d·ªØ li·ªáu t·ª´ snapshot Firebase (d√πng cho load + sync realtime)
    function applyFirebaseData(data) {
      if (data && data.options && Array.isArray(data.options) && data.options.length > 0) {
        options = data.options.map(o => ({
          name: o.name || '',
          weight: typeof o.weight === 'number' ? o.weight : 100 / data.options.length
        }));
        forcedResult = data.forcedResult != null ? data.forcedResult : null;
        syncUIFromOptions();
        renderWheel();
        updateForcedSelect();
      } else {
        options = [];
        forcedResult = null;
        optionsInput.value = '';
        renderWheel();
      }
    }

    // ========== Load + ƒë·ªìng b·ªô realtime t·ª´ Firebase ==========
    // Thi·∫øt b·ªã kh√°c ch·ªânh C√†i ƒë·∫∑t (ho·∫∑c options) ‚Üí thi·∫øt b·ªã n√†y t·ª± c·∫≠p nh·∫≠t, kh√¥ng c·∫ßn refresh
    function loadFromFirebase() {
      const ref = database.ref(DB_PATH);
      ref.on('value', function (snapshot) {
        try {
          const data = snapshot.val();
          applyFirebaseData(data);
        } catch (err) {
          console.error('Firebase sync error:', err);
        }
      }, function (err) {
        console.error('Load Firebase error:', err);
        resultBox.textContent = 'Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu t·ª´ Firebase.';
        resultBox.classList.remove('empty');
      });
    }

    // ƒê·ªìng b·ªô textarea v√† state t·ª´ options
    function syncUIFromOptions() {
      optionsInput.value = options.map(o => o.name).join('\n');
    }

    // ========== L∆∞u l√™n Firebase ==========
    function saveToFirebase() {
      try {
        const ref = database.ref(DB_PATH);
        ref.set({
          options: options.map(o => ({ name: o.name, weight: o.weight })),
          forcedResult: forcedResult
        });
      } catch (err) {
        console.error('Save Firebase error:', err);
        resultBox.textContent = 'L·ªói l∆∞u d·ªØ li·ªáu.';
        resultBox.classList.remove('empty');
      }
    }

    // ========== V·∫Ω v√≤ng quay ==========
    function renderWheel() {
      if (!wheelCanvas) return;
      canvas = wheelCanvas;
      ctx = canvas.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      const size = 380;
      canvas.width = size * dpr;
      canvas.height = size * dpr;
      ctx.scale(dpr, dpr);

      const centerX = size / 2;
      const centerY = size / 2;
      const radius = Math.min(centerX, centerY) - 10;

      ctx.clearRect(0, 0, size, size);

      if (!options.length) {
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#666';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Ch∆∞a c√≥ option', centerX, centerY);
        return;
      }

      // Giao di·ªán v√≤ng quay lu√¥n chia ƒë·ªÅu (kh√¥ng ph·ª• thu·ªôc % x√°c su·∫•t)
      const sliceAngle = (Math.PI * 2) / options.length;
      const colors = ['#e94560', '#0f3460', '#533483', '#2d4059', '#ea5455', '#1a1a2e', '#16213e', '#0f3460'];
      let startAngle = -Math.PI / 2; // B·∫Øt ƒë·∫ßu t·ª´ tr√™n (12h)

      for (let i = 0; i < options.length; i++) {
        const endAngle = startAngle + sliceAngle;

        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, startAngle, endAngle);
        ctx.closePath();
        ctx.fillStyle = colors[i % colors.length];
        ctx.fill();
        ctx.strokeStyle = '#1a1a2e';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Ch·ªØ n·∫±m gi·ªØa cung
        const midAngle = startAngle + sliceAngle / 2;
        const textRadius = radius * 0.65;
        const tx = centerX + Math.cos(midAngle) * textRadius;
        const ty = centerY + Math.sin(midAngle) * textRadius;
        ctx.save();
        ctx.translate(tx, ty);
        const deg = (midAngle * 180 / Math.PI + 90) % 360;
        if (deg > 90 && deg < 270) ctx.rotate(midAngle + Math.PI);
        else ctx.rotate(midAngle);
        ctx.fillStyle = '#fff';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = options[i].name.length > 12 ? options[i].name.slice(0, 10) + '‚Ä¶' : options[i].name;
        ctx.fillText(label, 0, 0);
        ctx.restore();

        startAngle = endAngle;
      }

      // V√≤ng tr√≤n trong
      ctx.beginPath();
      ctx.arc(centerX, centerY, 28, 0, Math.PI * 2);
      ctx.fillStyle = '#1a1a2e';
      ctx.fill();
      ctx.strokeStyle = '#e94560';
      ctx.lineWidth = 4;
      ctx.stroke();
    }

    // G√≥c m·ªói segment: lu√¥n chia ƒë·ªÅu (kh·ªõp v·ªõi giao di·ªán v√≤ng quay)
    function getSegmentAngles() {
      if (!options.length) return { startAngles: [], sliceAngle: 0 };
      const sliceAngle = (Math.PI * 2) / options.length;
      const startAngles = [];
      for (let i = 0; i < options.length; i++) {
        startAngles.push(-Math.PI / 2 + i * sliceAngle);
      }
      return { startAngles, sliceAngle };
    }

    // T√≠nh segment n·∫±m d∆∞·ªõi kim (g√≥c 12h = -PI/2) khi wheel ƒëang ·ªü g√≥c rotation
    function getSegmentUnderPointer(rotation) {
      if (!options.length) return 0;
      const n = options.length;
      const twoPi = Math.PI * 2;
      // ƒêi·ªÉm t·∫°i kim (canvas -PI/2) tr√™n wheel c√≥ g√≥c local = -PI/2 - rotation
      let localAngle = (-Math.PI / 2 - rotation) % twoPi;
      if (localAngle < 0) localAngle += twoPi;
      // Segment i c√≥ g√≥c local [-PI/2 + i*2PI/n, -PI/2 + (i+1)*2PI/n) => chu·∫©n h√≥a [0,2PI): [+3PI/2 + i*2PI/n, ...)
      const i = Math.floor((localAngle + Math.PI / 2) * n / twoPi) % n;
      return i < 0 ? i + n : i;
    }

    // ========== Ch·ªçn index theo tr·ªçng s·ªë (d√πng khi kh√¥ng c√≥ forced) ==========
    // D√πng x√°c su·∫•t t√≠ch l≈©y v·ªõi r trong [0,1) ƒë·ªÉ tr√°nh l·ªói khi 1 option 100% c√≤n l·∫°i 0%
    function getRandomByWeight() {
      if (!options.length) return 0;
      const total = options.reduce((s, o) => s + o.weight, 0) || 1;
      if (total <= 0) return 0;
      const r = Math.random();
      let acc = 0;
      for (let i = 0; i < options.length; i++) {
        acc += options[i].weight / total;
        if (r < acc) return i;
      }
      return options.length - 1;
    }

    // V·∫Ω v√≤ng quay v·ªõi g√≥c xoay (d√πng khi ƒëang quay)
    function redrawWheelWithRotation(rotation) {
      const size = 380;
      const centerX = size / 2;
      const centerY = size / 2;
      const radius = Math.min(centerX, centerY) - 10;
      const sliceAngle = (Math.PI * 2) / options.length;
      const colors = ['#e94560', '#0f3460', '#533483', '#2d4059', '#ea5455', '#1a1a2e', '#16213e', '#0f3460'];
      let startAngle = -Math.PI / 2;

      ctx.clearRect(0, 0, size, size);
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(rotation);
      ctx.translate(-centerX, -centerY);

      for (let i = 0; i < options.length; i++) {
        const endAngle = startAngle + sliceAngle;
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, startAngle, endAngle);
        ctx.closePath();
        ctx.fillStyle = colors[i % colors.length];
        ctx.fill();
        ctx.strokeStyle = '#1a1a2e';
        ctx.lineWidth = 2;
        ctx.stroke();
        const midAngle = startAngle + sliceAngle / 2;
        const textRadius = radius * 0.65;
        const tx = centerX + Math.cos(midAngle) * textRadius;
        const ty = centerY + Math.sin(midAngle) * textRadius;
        ctx.save();
        ctx.translate(tx, ty);
        const deg = (midAngle * 180 / Math.PI + 90) % 360;
        if (deg > 90 && deg < 270) ctx.rotate(midAngle + Math.PI);
        else ctx.rotate(midAngle);
        ctx.fillStyle = '#fff';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = options[i].name.length > 12 ? options[i].name.slice(0, 10) + '‚Ä¶' : options[i].name;
        ctx.fillText(label, 0, 0);
        ctx.restore();
        startAngle = endAngle;
      }

      ctx.restore();
      ctx.beginPath();
      ctx.arc(centerX, centerY, 28, 0, Math.PI * 2);
      ctx.fillStyle = '#1a1a2e';
      ctx.fill();
      ctx.strokeStyle = '#e94560';
      ctx.lineWidth = 4;
      ctx.stroke();
    }

    // Ch·ªâ l∆∞u forcedResult l√™n Firebase (ƒë·ªÉ thi·∫øt b·ªã kh√°c c√≥ th·ªÉ c√†i cho thi·∫øt b·ªã quay)
    function saveForcedResultToFirebase(value) {
      try {
        database.ref(DB_PATH).update({ forcedResult: value });
      } catch (err) {
        console.error('Save forcedResult error:', err);
      }
    }

    // ƒê·ªçc forcedResult t·ª´ DB tr∆∞·ªõc khi quay (thi·∫øt b·ªã kh√°c c√≥ th·ªÉ ƒë√£ c√†i)
    function readForcedResultFromFirebase() {
      return database.ref(DB_PATH).once('value').then(function (snapshot) {
        const data = snapshot.val();
        if (data && data.forcedResult != null) {
          const idx = data.forcedResult;
          return (idx >= 0 && idx < options.length) ? idx : null;
        }
        return null;
      });
    }

    // ========== Quay v√≤ng ==========
    function spinWheel() {
      if (isSpinning || !options.length) return;
      isSpinning = true;
      spinBtn.disabled = true;
      resultBox.textContent = 'ƒêang quay...';
      resultBox.classList.remove('empty');

      readForcedResultFromFirebase()
        .catch(function (err) {
          console.error('ƒê·ªçc forcedResult t·ª´ DB l·ªói:', err);
          return null;
        })
        .then(function (forcedFromDb) {
        let winIndex;
        var isForced = forcedFromDb != null;
        if (isForced) {
          winIndex = forcedFromDb;
          saveForcedResultToFirebase(null);
          forcedResult = null;
          updateForcedSelect();
        } else {
          winIndex = getRandomByWeight();
        }

        const { startAngles, sliceAngle } = getSegmentAngles();
        const midAngle = startAngles[winIndex] + sliceAngle / 2;
        const twoPi = Math.PI * 2;
        const startRotation = currentRotation;
        const exactTarget = -Math.PI / 2 - midAngle;
        // K·∫øt qu·∫£ b·∫Øt bu·ªôc: quay th√™m nhi·ªÅu v√≤ng (8‚Äì12), l√¢u h∆°n, d·ª´ng d·∫ßn r√µ r√†ng
        var fullTurns = isForced ? (8 + Math.random() * 5) : (5 + Math.random() * 2);
        var duration = isForced ? (4500 + Math.random() * 1500) : (3000 + Math.random() * 2000);
        // Lu√¥n quay th√™m √≠t nh·∫•t fullTurns v√≤ng V√Ä endRotation - startRotation >= 5œÄ (animation r√µ r√†ng)
        let k = Math.ceil((startRotation - exactTarget + 5 * Math.PI) / twoPi);
        if (k < fullTurns) k = fullTurns;
        const endRotation = exactTarget + k * twoPi;

        const startTime = performance.now();
        // Easing: d·ª´ng d·∫ßn m·∫°nh khi g·∫ßn ƒë√≠ch (quintic), tr√°nh gi·∫≠t
        function easeOutQuint(t) {
          t = Math.max(0, Math.min(1, t));
          return 1 - Math.pow(1 - t, 5);
        }

        function animate(now) {
          const elapsed = now - startTime;
          const t = Math.min(elapsed / duration, 1);
          const easeOut = easeOutQuint(t);
          const stepRotation = startRotation + (endRotation - startRotation) * easeOut;
          redrawWheelWithRotation(stepRotation);

        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          currentRotation = endRotation;
          isSpinning = false;
          spinBtn.disabled = false;
          var actualIndex = getSegmentUnderPointer(endRotation);
          resultBox.textContent = 'K·∫øt qu·∫£: ' + options[actualIndex].name;
          resultBox.classList.remove('empty');
        }
        }

        redrawWheelWithRotation(startRotation);
        requestAnimationFrame(animate);
      });
    }

    // C·∫≠p nh·∫≠t n√∫t C·∫≠p nh·∫≠t v√≤ng quay
    updateBtn.addEventListener('click', () => {
      const lines = optionsInput.value.split('\n').map(s => s.trim()).filter(Boolean);
      if (!lines.length) {
        resultBox.textContent = 'Vui l√≤ng nh·∫≠p √≠t nh·∫•t 1 option.';
        resultBox.classList.remove('empty');
        return;
      }
      const total = lines.length;
      options = lines.map(name => ({ name, weight: 100 / total }));
      renderWheel();
      saveToFirebase();
      updateForcedSelect();
      resultBox.textContent = 'ƒê√£ c·∫≠p nh·∫≠t ' + options.length + ' option.';
      resultBox.classList.remove('empty');
    });

    spinBtn.addEventListener('click', spinWheel);

    // Modal c√†i ƒë·∫∑t
    function updateForcedSelect() {
      forcedResultSelect.innerHTML = '<option value="">-- Kh√¥ng ch·ªçn --</option>';
      options.forEach((o, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = o.name;
        if (forcedResult === i) opt.selected = true;
        forcedResultSelect.appendChild(opt);
      });
    }

    // Khi ƒë·ªïi "K·∫øt qu·∫£ b·∫Øt bu·ªôc" ‚Üí l∆∞u l√™n DB ngay (thi·∫øt b·ªã kh√°c ƒë·ªçc ƒë∆∞·ª£c)
    forcedResultSelect.addEventListener('change', function () {
      const val = forcedResultSelect.value;
      forcedResult = val === '' ? null : parseInt(val, 10);
      saveForcedResultToFirebase(forcedResult);
    });

    function openSettingsModal() {
      settingsOptionsList.innerHTML = '';
      options.forEach((o, i) => {
        const row = document.createElement('div');
        row.className = 'setting-row';
        const label = document.createElement('label');
        label.htmlFor = 'weight-' + i;
        label.textContent = o.name;
        const input = document.createElement('input');
        input.type = 'number';
        input.id = 'weight-' + i;
        input.min = 0;
        input.max = 100;
        input.step = 0.5;
        input.value = o.weight;
        row.appendChild(label);
        row.appendChild(input);
        row.appendChild(document.createTextNode(' %'));
        settingsOptionsList.appendChild(row);
      });
      updateForcedSelect();
      updateWeightSum();
      settingsModal.classList.add('show');
    }

    function updateWeightSum() {
      let sum = 0;
      options.forEach((_, i) => {
        const input = document.getElementById('weight-' + i);
        if (input) sum += parseFloat(input.value) || 0;
      });
      weightSumEl.textContent = 'T·ªïng: ' + sum.toFixed(1) + '%';
      weightSumEl.classList.toggle('error', Math.abs(sum - 100) > 0.5);
    }

    document.getElementById('settingsModal').addEventListener('input', updateWeightSum);

    const settingsBtn = document.getElementById('settingsBtn');
    if (settingsBtn) settingsBtn.addEventListener('click', openSettingsModal);
    modalClose.addEventListener('click', () => settingsModal.classList.remove('show'));
    modalCancel.addEventListener('click', () => settingsModal.classList.remove('show'));
    modalSave.addEventListener('click', () => {
      const newOptions = options.map((o, i) => {
        const input = document.getElementById('weight-' + i);
        const w = input ? parseFloat(input.value) : o.weight;
        return { name: o.name, weight: isNaN(w) || w < 0 ? 0 : w };
      });
      const sum = newOptions.reduce((s, o) => s + o.weight, 0);
      if (Math.abs(sum - 100) > 0.5) {
        weightSumEl.classList.add('error');
        return;
      }
      options = newOptions;
      forcedResult = forcedResultSelect.value === '' ? null : parseInt(forcedResultSelect.value, 10);
      saveToFirebase();
      renderWheel();
      settingsModal.classList.remove('show');
      resultBox.textContent = 'ƒê√£ l∆∞u c√†i ƒë·∫∑t.';
      resultBox.classList.remove('empty');
    });

    // Kh·ªüi t·∫°o
    loadFromFirebase();
    renderWheel();
    // M·ªü modal c√†i ƒë·∫∑t x√°c su·∫•t khi v√†o trang b·∫±ng link t·ª´ web desktop (?open=settings)
    if (window.location.search.includes('open=settings') || window.location.hash === '#settings') {
      setTimeout(openSettingsModal, 300);
    }
  </script>
</body>
</html>
